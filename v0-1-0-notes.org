
* Forcing function
+ find a textbook example to reproduce in a test
+ first layer only
+ first layer has arrows out but not in
+ subsequent layers can have arrows out and in
+ user provides input of shape either (n_compartments,) or (n_layers, 2, n_compartments)
+ former case: tc from ff comp to other comps; there is no xfer in/out of this compartment in subsequent layers
+ latter case: for each layer, first row is arrows out; second row is arrows in (zeros for first layer)
+ the ff is represented in the model as an additional compartment
+ ff is compatible with prelayer, but user cannot provide a prelayer tac for it
+ solver must skip over ff compartment for the first layer

* Voiding
** API

#+begin_src python
from dataclasses import dataclass
import numpy as np

@dataclass
class Voiding:
    times : list | numpy.array
    fractions : numpy.array
#+end_src

times:
+ h

fractions:
+ shape (num layers, num compartments)
+ 0--1
+ fraction in each layer-compartment voided at times in `times`

Soln init:
voiding : list[Voiding]

** to solve a layer
+ for each voiding, create VoidingLayer object for the layer

#+begin_src python
from dataclasses import dataclass
import numpy as np

@dataclass
class VoidingLayer:
    time : float
    fractions : numpy.array
#+end_src

fractions:
+ length (num compartments)

+ discard VoidingLayer object if fractions are all zero
+ put VoidingLayer objects (with fractions not all zero) into a list
+ sort the list by void time

#+begin_src python
sorted_voiding_layer_list = sorted(voiding_layer_list, key=lambda x: x.time)
#+end_src

solve the layer:
+ solve from initial time to first VoidingLayer.time
+ change the initial conditions for the next interval: (1 - VoidingLayer.fractions) * soln
+ solve from first VoidingLayer.time to second VoidingLayer.time, etc
+ solve last VoidingLayer.time to end time
